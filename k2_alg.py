# -*- coding: utf-8 -*-
"""k2_alg.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ulBNSEAycgA_ksKV15iTtMEm2epuaox8
"""

import pandas as pd
import numpy as np
import copy
import math

from functools import reduce
from decimal import Decimal
import itertools

from graphviz import Digraph

import TransEntropy_mod as te

def graph_simple(df, eng = 'dot'):
    edge_style = ""
    g = Digraph(engine=eng)
    in_graph = []
    for k, row in enumerate(df.index):
        if any(df.loc[row]):
            g.node(str(row),row, shape='oval', fontsize='10', width='0', style='filled', fillcolor='#c9c9c9', color="gray")
            in_graph.append(row)

              
    for c, col in enumerate(df.columns):
      if any(df[col]):
        if col not in in_graph:
            g.node(str(col), col, shape='oval', fontsize='10', width='0', style='filled', fillcolor='#c9c9c9', color="gray") 

    for j, col in enumerate(df.columns):
        for i, row in enumerate(df.index):
            if(df[col][i]):
                g.edge(str(row), str(col), label=str(df.at[row,col]), style= edge_style, color='black')  
    return g



def graph_from_dict(dictionary, eng = 'dot'):
    edge_style = ""
    g = Digraph(engine=eng)
   
    for k in dictionary.keys():
      if any([k in sub for sub in dictionary.values() for key in dictionary.keys()]) or dictionary[k]:
        g.node(str(k),k, shape='oval', fontsize='10', width='0', style='filled', fillcolor='#c9c9c9', color="gray") 

    for k, i in dictionary.items():
        for it in i:
            g.edge(str(it), str(k), label='',style= edge_style, color='black')  
    return g

fake_data = pd.DataFrame(columns=["x1", "x2", "x3"], data= np.transpose([[1,1,0,1,0,0,1,0,1,0], [0,1,0,1,0,1,1,0,1,0], [0,1,1,1,0,1,1,0,1,0]]))



def alpha(df, i, parents): 
  parents = np.sort(parents)
  states = list(map(list, itertools.product([0, 1], repeat=len(parents)+1)))
  states_mod = [["".join(map(str,sublist[:len(sublist)-1]))]+[str(sublist[-1])] for sublist in states]
  gpd_values = pd.DataFrame()
  
  if len(parents):
    label_parents = ''.join(parents)
    df_to_group = pd.DataFrame(columns = [label_parents, df.columns[i]],
                                data = np.transpose(
                                    [df.astype(str)[parents].apply(lambda x: "".join(x), axis=1).values,
                                    [str(item) for item in df[df.columns[i]]]]))
    
    gpd_values = df_to_group.groupby(by=
                                     [df_to_group[label_parents],
                                      df.columns[i]]).size()
    
    gpd_values = gpd_values.reset_index(name='size')
   
    for state in states_mod:
      if not state in gpd_values[[label_parents, df.columns[i]]].values.tolist() :
        gpd_values.loc[len(gpd_values)] = state+[0]
        gpd_values.sort_values(by=[label_parents, df.columns[i]], inplace=True)
    gpd_values.reset_index(inplace=True)
    gpd_values = gpd_values['size']
    
  else:
    gpd_values = df.groupby(df.columns[i]).size().values
  return gpd_values



def get_N(df, i, parents):
  
  parents = np.sort(parents)
  states = list(map(list, itertools.product([0, 1], repeat=len(parents))))
  gpd_values = None
  N = []
  if len(parents):
    cols_to_group = ([index for index in parents])
    cols_to_group.insert(0,df.columns[i])
    N = df[cols_to_group].groupby(cols_to_group[1:]).size()
    N = N.reset_index(name='size')
    
    for state in states:
      if not state in N[cols_to_group[1:]].values.tolist() :
        N.loc[len(N)] = state+[0]
        N.sort_values(by=cols_to_group[1:], inplace=True)
    N.reset_index(inplace = True)
    N = N['size']
  else:
    N = df.groupby(by=df.columns[i]).size().values.sum()
  return N



def f_ch(df, x_i, pi):
  #prod = 1
  prod = 0
  r_i = len(df[df.columns[x_i]].unique())
  alfa = alpha(df, x_i, pi)
  q_i = reduce(lambda x, y: x*y, [len(pd.unique(df[pai].values)) for pai in pi]) if pi  else 0
  Nij = get_N(df, x_i, pi)

  if pi:
    for j in np.arange(0,q_i):
      #prod *= math.factorial(r_i - 1)/math.factorial(Nij[j] + r_i - 1)
      prod += math.log(math.factorial(r_i - 1)) - math.log(math.factorial(Nij[j] + r_i - 1))
      for i in np.arange(0,r_i):
        #prod *= math.factorial(alfa[2*j + i])
        prod += math.log(math.factorial(alfa[2*j + i]))
  else:
    #prod *= math.factorial(r_i - 1)/math.factorial(Nij + r_i - 1)
    prod += math.log(math.factorial(r_i - 1)) - math.log(math.factorial(Nij + r_i - 1))
    for i in np.arange(0, r_i):
      prod += math.log(math.factorial(alfa[i]))
      #prod *= math.factorial(alfa[2*j + i])
  
  return prod

def f_mdl(df,x_i,pi, c):
  N = len(df)
  r_i = len(df[df.columns[x_i]].unique())
  q_i = reduce(lambda x, y: x*y, [len(pd.unique(df[pai].values)) for pai in pi]) if pi  else 0
  Nij = get_N(df, x_i, pi)
  Nijk = alpha(df, x_i, pi)
  pbs = 0
  
  if(pi):
    for j in np.arange(0,q_i):
      for i in np.arange(0,r_i):
        if Nijk[2*j + i] and Nij[j]:
          pbs += Nijk[2*j + i]*(math.log(Nijk[2*j + i]) - math.log(Nij[j]))          
        elif Nij[j]:
          pbs += - math.log(Nij[j])
    pbs += -(c/2)*math.log(N)*q_i*(r_i -1)
  else:
    for i in np.arange(0,r_i):
      pbs += Nijk[i]*(math.log(Nijk[i]) - math.log(Nij))
    pbs += -(c/2)*math.log(N)*(r_i -1)
  
  return pbs

def k2(df_general, tree_ogn, df_lags, c):
  tree = copy.deepcopy(tree_ogn)
  dict_p = {}
 
  
  sigma = 0
   
  dict_lags = te.get_all_shifts(df_lags.columns, df_lags.copy())
  nodes = []
  
  dfs_list = []
  
  for col in df_general.columns:
    dfs_list.append(te.gen_df_iteration(df_general, col, dict_lags))
  
    
    
  parents = [[] for node in df_general.columns]
   
  count = 0
  for xi,col in enumerate(df_general.columns):
    df = dfs_list[count]
    count += 1
    df.dropna(inplace=True)
    
    #pold = f_ch(df, xi, parents[xi])
   
    pold = f_mdl(df, xi, parents[xi], c)
    
    tree_xi = []
    if tree:
      tree_xi = tree[col]
    
    f_ances = []
    while (True):
      test_parents = [parents[xi]+[ances] for ances in tree_xi] if tree_xi else []

      #f_ances = [f_ch(df, xi,parent) for parent in test_parents] if test_parents else [f_ch(df, xi, test_parents)]
      f_ances = [f_mdl(df, xi,parent,1) for parent in test_parents] if test_parents else [f_mdl(df, xi, test_parents,c)]
      j_max = np.argmax(f_ances)

      sigma = f_ances[j_max]> pold
        
      if sigma:
        parents[xi] = parents[xi] + [no for no in [tree_xi[j_max]] if no not in parents[xi]]
        pold = f_ances[j_max]
  
      if tree_xi:
        del tree_xi[j_max]
      
      if(not sigma) or  (not tree_xi):
        break
        
  for i,parent in enumerate(parents):
    dict_p[df_general.columns[i]] = parent
  return dict_p

def df_to_dictTree(df):
    dict_tree = {}
    for col in df.columns:
        non_zero = df[col].nonzero()
        dict_tree[col] = df[col].index[non_zero].values.tolist()
    return dict_tree

def app_roll_mean(df, window):
    roll  = df.copy().rolling(window).mean() 
    roll.dropna(inplace=True)
    roll = roll.round(decimals=0).copy()
    roll.reset_index(drop=True, inplace=True)
    return roll



dict_chest = {'present': 1, 'absent':0, 'normal': 1, 'abnormal':0, True: 1, False: 0, 'visit': 1, 'no_visit': 0, 'smoker' : 1, 'non_smoker': 0}
chest_tree = {'Dyspnea':['Cancer', 'TbOrCa', 'Tuberculosis'], 
              'XRay':['Travel', 'Tuberculosis'], 
              'TbOrCa':['Bronchitis', 'Cancer', 'Travel'],
             'Tuberculosis':['Travel','TbOrCa', 'Cancer'],
             'Cancer': ['TbOrCa', 'Smoking', 'Bronchitis'],
             'Travel':['Smoking'],
             'Smoking': ['Travel'],
             'Bronchitis':['Cancer', 'Smoking']}


def gen_clean_df(df_lags, k2_return):
  df_clean = pd.DataFrame(data=np.zeros([len(df_lags.columns),len(df_lags.columns)], dtype=float), columns= df_lags.columns, index= df_lags.columns) 

  for key, values in k2_return.items():
    node_son = key
    lista_son = te. get_lags_ances_df(df_lags, node_son,0, {}, [], {})[1]

    for node in values:
      split_name = node.split('-')
      node_ref = split_name[0]
      lag = split_name[1].split('_')[1]
      idx_ref = int(split_name[1].split('_')[0])

      count = 0
      path_list = lista_son[node_ref][idx_ref][::-1]

      if len(lista_son[node_ref][idx_ref][::-1]) == 1:
          print('here ',node_ref, node_son)
          df_clean.at[node_ref,node_son] = 1
      while count < len(path_list) -1:
        print('here ',node_ref, node_son)
        df_clean.at[path_list[count], path_list[count+1]] = 1
        count +=1
      if not len(lista_son[node_ref][idx_ref][::-1]) == 1:
        df_clean.at[node_ref, path_list[0]] = 1

  return df_clean

